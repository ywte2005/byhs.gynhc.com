# 前端登录拦截实现总结

## 问题描述

前端请求接口时，后端返回 `{"code":401,"msg":"请登录后操作"}` 时，需要实现全局拦截，自动跳转到登录页。

## 解决方案

### 1. 修改内容

**文件**：`cool-unix/.cool/service/index.ts`

**修改位置**：在响应数据解析的 switch 语句中添加 401 和 403 的处理

```typescript
switch (code) {
    case 1000:
        resolve(data);
        break;
    // 401 未登录或token失效
    case 401:
        user.logout();
        reject({ message: message || t("请登录后操作"), code } as Response);
        break;
    // 403 权限不足
    case 403:
        reject({ message: message || t("权限不足"), code } as Response);
        break;
    default:
        reject({ message, code } as Response);
        break;
}
```

### 2. 实现原理

#### 拦截流程
```
接口请求
    ↓
收到响应 (HTTP 200)
    ↓
解析响应体中的 code
    ↓
├─ code = 1000 → 返回数据
├─ code = 401 → 调用 user.logout() → 跳转登录页
├─ code = 403 → 提示权限不足（不跳转）
└─ 其他 → 提示错误信息
```

#### 登出流程
```
user.logout()
    ↓
清除本地数据
├─ storage.remove("userInfo")
├─ storage.remove("token")
└─ storage.remove("refreshToken")
    ↓
调用 router.login()
    ↓
跳转到登录页 (/pages/user/login)
使用 reLaunch 模式（清空页面栈）
```

### 3. 已有功能

项目已经实现了完整的认证机制：

#### Token 自动刷新
- Token 过期前自动刷新
- 刷新期间请求进入队列
- 刷新成功后统一执行

#### 防抖处理
- 登录页跳转使用 300ms 防抖
- 防止多个 401 同时触发重复跳转

#### 智能跳转
- 已在登录页不重复跳转
- 登录成功后自动返回之前页面

## 后端接口规范

### 返回格式要求

**成功**
```json
{
  "code": 1000,
  "msg": "操作成功",
  "data": {}
}
```

**未登录**
```json
{
  "code": 401,
  "msg": "请登录后操作",
  "data": null
}
```

**权限不足**
```json
{
  "code": 403,
  "msg": "权限不足",
  "data": null
}
```

### 状态码定义

| 状态码 | 说明 | 前端处理 |
|--------|------|----------|
| 1000 | 成功 | 返回数据 |
| 401 | 未登录 | 清除数据，跳转登录页 |
| 403 | 权限不足 | 提示错误，不跳转 |
| 其他 | 业务错误 | 提示错误信息 |

## 测试方法

### 1. 使用测试页面

访问：`/pages/demo/test-auth`

测试功能：
- ✅ 测试正常请求
- ✅ 测试 401 未登录拦截
- ✅ 测试 403 权限不足
- ✅ 测试 Token 自动刷新

### 2. 手动测试

```typescript
// 清除 token
storage.remove('token');

// 发起请求
request({ url: '/api/user/info' })
    .catch(err => {
        // 应该自动跳转到登录页
        console.log(err.code); // 401
    });
```

### 3. 浏览器测试

```javascript
// 在浏览器控制台执行
fetch("http://localhost:9900/api/task/list", {
    headers: {
        "authorization": "invalid_token"
    }
})
.then(res => res.json())
.then(data => {
    console.log(data);
    // 应该返回 {"code":401,"msg":"请登录后操作"}
    // 前端会自动跳转到登录页
});
```

## 文件清单

### 修改的文件
- ✅ `cool-unix/.cool/service/index.ts` - 添加 401/403 拦截

### 新增的文件
- ✅ `cool-unix/docs/登录拦截机制说明.md` - 详细文档
- ✅ `cool-unix/pages/demo/test-auth.uvue` - 测试页面
- ✅ `docs/前端登录拦截实现总结.md` - 本文档

### 相关文件（无需修改）
- `cool-unix/.cool/store/user.ts` - 用户状态管理
- `cool-unix/.cool/router/index.ts` - 路由管理
- `cool-unix/.cool/utils/storage.ts` - 本地存储

## 特性说明

### 1. 双层拦截
- HTTP 状态码 401 拦截（服务器级别）
- 业务状态码 401 拦截（应用级别）

### 2. 自动刷新
- Token 过期自动刷新
- 请求队列管理
- 失败自动登出

### 3. 用户体验
- 防抖跳转（300ms）
- 智能返回（登录后回到之前页面）
- 错误提示（多语言支持）

### 4. 安全性
- 自动清除敏感数据
- Token 提前 5 秒过期判定
- RefreshToken 双重保护

## 注意事项

1. **后端必须返回正确的状态码**
   - 未登录必须返回 `code: 401`
   - 不要使用其他状态码表示未登录

2. **Token 过期时间**
   - 建议 Token 有效期：2 小时
   - 建议 RefreshToken 有效期：7 天
   - 前端会提前 5 秒判定过期

3. **登录页路径**
   - 默认：`/pages/user/login`
   - 如需修改，在 `router.defaultPath()` 中配置

4. **多端兼容**
   - 已兼容 H5、App、小程序
   - 使用 uni-app 标准 API

## 常见问题

### Q1: 为什么有两层 401 拦截？
**A**: 
- HTTP 401：服务器直接返回 401 状态码
- 业务 401：HTTP 200，但响应体中 code=401
- 两种情况都需要处理

### Q2: 403 为什么不跳转登录页？
**A**: 403 表示已登录但权限不足，不需要重新登录，只需要提示用户权限不足。

### Q3: Token 刷新失败会怎样？
**A**: 刷新失败会自动调用 `user.logout()`，清除所有数据并跳转登录页。

### Q4: 如何忽略某些接口的 Token 校验？
**A**: 在 `config/index.ts` 中配置 `ignoreTokens` 数组：
```typescript
export const ignoreTokens: string[] = [
    "/api/user/login",
    "/api/user/register"
];
```

## 更新日志

### 2026-02-04
- ✅ 添加业务状态码 401 拦截
- ✅ 添加业务状态码 403 拦截
- ✅ 创建测试页面
- ✅ 完善文档说明

---

**实现状态**：✅ 已完成  
**测试状态**：⏳ 待测试  
**文档状态**：✅ 已完成  

**负责人**：前端开发团队  
**更新时间**：2026-02-04
